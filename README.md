# 学习日志
## ch0-2
这个就直接按实验手册来做一路绿灯（除了qemu被我动了一下不能直接调用，后面重新安装一下就好了）
## ch3
这个还好就是在task.rs中的TaskControlBlock结构体增加sys_call_times数组, 用于记录当前task中各个系统调用的次数没遇到太大的问题
## ch4
为了支持 mmap 动态申请内存地址空间，我们在 MemorySet 结构中添加一个新的成员 map_tree，用来存放不连续的内存区域。map_tree 是一个 BTreeMap，将虚拟页号映射到页帧跟踪器，使得在多次 mmap 调用时能够有效管理这些不连续的内存区域。此外，在 munmap 调用时，map_tree 负责释放相应的页帧，并通过触发 drop trait 使内存页分配器回收这些内存页，从而实现资源的自动管理和释放。
主要是要检查是否实现正确的地址转换和边界检查，并确保线程安全性，可以有效解决在用户空间进行虚拟地址手动翻译的问题。
## ch5
通过实现 sys_spawn 系统调用，我们能够直接创建一个新进程并执行指定的目标程序，而无需像 fork 那样复制父进程的地址空间，这不仅简化了进程创建过程，还提高了系统资源的利用效率，确保新进程能够高效地运行指定的程序。
## ch6
通过实现 sys_linkat、sys_unlinkat 和 sys_stat 系统调用，我们能够在文件系统中创建硬链接、取消文件路径链接以及获取文件状态信息。这些系统调用扩展了文件系统的功能，提供了更强的文件管理能力。
## ch8
通过实现 sys_eventfd2 系统调用，我们可以创建一个事件通知的文件描述符 eventfd，其核心是一个 64 位无符号整数的计数器。根据参数的设置，我们可以选择以非信号量模式或信号量模式创建 eventfd，并通过读取和写入操作实现事件通知的功能，从而提供了灵活和高效的事件通知机制